export interface GitHubFile {
  path: string;
  content: string;
}

export interface GitHubExportData {
  files: GitHubFile[];
  shellCommands: string[];
  description: string;
}

export class GitHubExportParser {
  private artifacts: string[] = [];
  private files: GitHubFile[] = [];
  private shellCommands: string[] = [];
  private description: string = '';

  constructor() {
    this.reset();
  }

  /**
   * Parse boltArtifact blocks and extract files and commands for GitHub export
   */
  parseArtifacts(artifacts: string[]): GitHubExportData {
    this.reset();
    this.artifacts = artifacts;

    for (const artifact of artifacts) {
      this.parseArtifact(artifact);
    }

    return {
      files: this.files,
      shellCommands: this.shellCommands,
      description: this.description
    };
  }

  /**
   * Parse a single boltArtifact block
   */
  private parseArtifact(artifact: string): void {
    // Extract description (text outside of boltAction tags)
    const descriptionMatch = artifact.replace(/<boltAction[^>]*>[\s\S]*?<\/boltAction>/g, '').trim();
    if (descriptionMatch) {
      this.description += descriptionMatch + '\n';
    }

    // Parse boltAction tags
    const actionRegex = /<boltAction\s+([^>]+?)>([\s\S]*?)<\/boltAction>/g;
    let match;

    while ((match = actionRegex.exec(artifact)) !== null) {
      const [, attributesStr, content] = match;
      const attributes = this.parseAttributes(attributesStr);
      
      if (attributes.type === 'file' && attributes.filePath) {
        this.files.push({
          path: attributes.filePath,
          content: content.trim()
        });
      } else if (attributes.type === 'shell') {
        const commands = content
          .split('\n')
          .map(cmd => cmd.trim())
          .filter(cmd => cmd.length > 0);
        
        this.shellCommands.push(...commands);
      }
    }
  }

  /**
   * Parse attributes from boltAction tag
   */
  private parseAttributes(attributesStr: string): Record<string, string> {
    const attributes: Record<string, string> = {};
    const attrRegex = /(\w+)="([^"]*)"/g;
    let match;

    while ((match = attrRegex.exec(attributesStr)) !== null) {
      attributes[match[1]] = match[2];
    }

    return attributes;
  }

  /**
   * Generate a README.md file with project description and setup instructions
   */
  generateReadme(): GitHubFile {
    let readmeContent = '# WebcraftAI Generated Project\n\n';

    if (this.description.trim()) {
      readmeContent += `## Description\n\n${this.description.trim()}\n\n`;
    }

    if (this.shellCommands.length > 0) {
      readmeContent += '## Setup Instructions\n\n';
      readmeContent += 'To run this project:\n\n';
      readmeContent += '```bash\n';
      this.shellCommands.forEach(cmd => {
        readmeContent += `${cmd}\n`;
      });
      readmeContent += '```\n\n';
    }

    readmeContent += '## Files\n\n';
    this.files.forEach(file => {
      readmeContent += `- \`${file.path}\`\n`;
    });

    readmeContent += '\n---\n*Generated by WebcraftAI*\n';

    return {
      path: 'README.md',
      content: readmeContent
    };
  }

  /**
   * Get all files including the generated README
   */
  getAllFiles(): GitHubFile[] {
    const allFiles = [...this.files];
    
    // Add README if it doesn't already exist
    const hasReadme = this.files.some(file => 
      file.path.toLowerCase() === 'readme.md' || 
      file.path.toLowerCase() === 'readme'
    );
    
    if (!hasReadme) {
      allFiles.push(this.generateReadme());
    }

    return allFiles;
  }

  /**
   * Reset parser state
   */
  reset(): void {
    this.artifacts = [];
    this.files = [];
    this.shellCommands = [];
    this.description = '';
  }

  /**
   * Get debug information
   */
  getDebugInfo() {
    return {
      artifactsCount: this.artifacts.length,
      filesCount: this.files.length,
      shellCommandsCount: this.shellCommands.length,
      descriptionLength: this.description.length,
      files: this.files.map(f => f.path),
      shellCommands: this.shellCommands
    };
  }
}

/**
 * Utility function to parse artifacts and prepare for GitHub export
 */
export function prepareGitHubExport(artifacts: string[]): GitHubExportData {
  const parser = new GitHubExportParser();
  return parser.parseArtifacts(artifacts);
}

/**
 * Utility function to get all files ready for GitHub upload
 */
export function getFilesForGitHub(artifacts: string[]): GitHubFile[] {
  const parser = new GitHubExportParser();
  parser.parseArtifacts(artifacts);
  return parser.getAllFiles();
} 